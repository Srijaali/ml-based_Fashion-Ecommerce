from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List, Optional, Union
from sqlalchemy import text
from app.db.database import get_db
from app.db.models.reviews import Review
from app.schemas.reviews_schema import ReviewCreate, ReviewOut, ReviewBase, ReviewUpdate
from app.customer_auth import get_current_customer, CustomerResponse
from app.dependencies import get_current_admin, AdminResponse
from app.core.auth import get_current_admin as _get_current_admin_core
from fastapi.security import HTTPAuthorizationCredentials
from app.core.auth import auth_scheme

router = APIRouter()

# Helper to get either admin or customer for delete endpoint
def get_admin_or_customer(
    credentials: HTTPAuthorizationCredentials = Depends(auth_scheme),
    db: Session = Depends(get_db)
) -> Union[AdminResponse, CustomerResponse]:
    """Helper that accepts either admin or customer token for delete operations"""
    from app.core.auth import decode_access_token
    from jose import JWTError
    import jwt
    import os
    
    SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key-change-in-production")
    ALGORITHM = "HS256"
    
    try:
        token = credentials.credentials
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        token_type = payload.get("type")
        
        if token_type == "admin":
            admin = _get_current_admin_core(credentials, db)
            return AdminResponse(
                admin_id=admin.admin_id,
                username=admin.username,
                email=admin.email,
                is_active=admin.is_active
            )
        elif token_type == "customer":
            return get_current_customer(credentials, db)
        else:
            raise HTTPException(401, "Invalid token type")
    except (JWTError, HTTPException):
        raise HTTPException(401, "Invalid token")


@router.post("/create")
def create_review(
    article_id: int,
    review_text: str,
    current_customer: CustomerResponse = Depends(get_current_customer),
    db: Session = Depends(get_db)
):
    """Create a review (requires authentication)"""
    
    # Check if customer has purchased this article
    purchased = db.execute(
        text("""
            SELECT 1 FROM order_items oi
            JOIN orders o ON oi.order_id = o.order_id
            WHERE o.customer_id = :customer_id 
            AND oi.article_id = :article_id
            LIMIT 1
        """),
        {
            "customer_id": current_customer.customer_id,
            "article_id": article_id
        }
    ).fetchone()
    
    if not purchased:
        raise HTTPException(
            status_code=400, 
            detail="You can only review products you've purchased"
        )
    
    # Insert review (auto-rating will be generated by trigger)
    db.execute(
        text("""
            INSERT INTO reviews (
                customer_id, article_id, review_text, created_at
            )
            VALUES (
                :customer_id, :article_id, :review_text, NOW()
            )
        """),
        {
            "customer_id": current_customer.customer_id,
            "article_id": article_id,
            "review_text": review_text
        }
    )
    db.commit()
    
    return {"message": "Review created successfully"}

@router.get("/", response_model=List[ReviewOut])
def get_all_reviews(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return db.query(Review).order_by(Review.created_at.desc()).offset(skip).limit(limit).all()


# ---------------------------
# GET REVIEWS FOR ARTICLE
# ---------------------------
@router.get("/article/{article_id}", response_model=List[ReviewOut])
def get_reviews_by_article(article_id: str, db: Session = Depends(get_db)):
    return db.query(Review).filter(Review.article_id == article_id).order_by(Review.created_at.desc()).all()


# ---------------------------
# GET REVIEWS FOR CUSTOMER
# ---------------------------
@router.get("/customer/{customer_id}", response_model=List[ReviewOut])
def get_reviews_by_customer(customer_id: str, db: Session = Depends(get_db)):
    return db.query(Review).filter(Review.customer_id == customer_id).order_by(Review.created_at.desc()).all()

# get review by review id
@router.get("/{review_id}", response_model=ReviewOut)
def get_review(review_id: str, db: Session = Depends(get_db)):
    db_review = db.query(Review).filter(Review.review_id == review_id).first()
    if not db_review:
        raise HTTPException(status_code=404, detail="review not found")
    return db_review


# ---------------------------
# CREATE REVIEW (with auto-rating) - Customer authenticated
# ---------------------------
@router.post("/", response_model=ReviewOut, status_code=201)
def create_review_authenticated(
    payload: ReviewCreate, 
    current_customer: CustomerResponse = Depends(get_current_customer),
    db: Session = Depends(get_db)
):
    # Ensure customer can only create reviews for themselves
    if payload.customer_id != current_customer.customer_id:
        raise HTTPException(status_code=403, detail="Cannot create review for another customer")

    # call DB function to generate rating and insert review
    sql = text("""
        SELECT niche_data.add_review(
            :cid,
            :aid,
            :txt
        )
    """)

    db.execute(sql, {
        "cid": payload.customer_id,
        "aid": payload.article_id,
        "txt": payload.review_text
    })
    db.commit()

    # fetch the created review
    row = db.execute(text("""
        SELECT *
        FROM niche_data.reviews
        WHERE customer_id = :cid AND article_id = :aid
        ORDER BY created_at DESC
        LIMIT 1
    """), {
        "cid": payload.customer_id,
        "aid": payload.article_id
    }).mappings().first()

    if not row:
        raise HTTPException(500, "Review not inserted")

    return row

# ---------------------------
# UPDATE REVIEW (Customer authenticated - can only update own reviews)
# ---------------------------
@router.put("/{review_id}", response_model=ReviewOut)
def update_review(
    review_id: int, 
    payload: ReviewUpdate, 
    current_customer: CustomerResponse = Depends(get_current_customer),
    db: Session = Depends(get_db)
):
    # Check if review belongs to current customer
    review_check = db.execute(
        text("SELECT customer_id FROM niche_data.reviews WHERE review_id = :rid"),
        {"rid": review_id}
    ).fetchone()
    
    if not review_check:
        raise HTTPException(404, "Review not found")
    
    if review_check[0] != current_customer.customer_id:
        raise HTTPException(403, "Cannot update another customer's review")

    # if text updated → regenerate rating
    if payload.review_text:
        sql = text("""
            UPDATE niche_data.reviews
            SET review_text = :txt,
                rating = niche_data.generate_rating_from_text(:txt)
            WHERE review_id = :rid
            RETURNING *
        """)
        row = db.execute(sql, {
            "rid": review_id,
            "txt": payload.review_text
        }).mappings().first()
    else:
        sql = text("""
            UPDATE niche_data.reviews
            SET rating = :rating
            WHERE review_id = :rid
            RETURNING *
        """)
        row = db.execute(sql, {
            "rid": review_id,
            "rating": payload.rating
        }).mappings().first()

    db.commit()

    if not row:
        raise HTTPException(404, "Review not found")

    return row


# ---------------------------
# DELETE REVIEW (Customer can delete own reviews, Admin can delete any)
# ---------------------------
@router.delete("/{review_id}", status_code=200)
def delete_review(
    review_id: int,
    user: Union[AdminResponse, CustomerResponse] = Depends(get_admin_or_customer),
    db: Session = Depends(get_db)
):
    """
    Delete a review.
    Customers can delete their own reviews.
    Admins can delete any review.
    """
    # Check if review exists
    review_check = db.execute(
        text("SELECT customer_id FROM niche_data.reviews WHERE review_id = :rid"),
        {"rid": review_id}
    ).fetchone()
    
    if not review_check:
        raise HTTPException(404, "Review not found")
    
    # Admin can delete any review, customer can only delete their own
    if isinstance(user, AdminResponse):
        # Admin override - can delete any review
        pass
    elif isinstance(user, CustomerResponse):
        # Customer can only delete their own reviews
        if str(review_check[0]) != str(user.customer_id):
            raise HTTPException(403, "Cannot delete another customer's review")
    
    result = db.execute(text("""
        DELETE FROM niche_data.reviews
        WHERE review_id = :rid
    """), {"rid": review_id})

    db.commit()

    if result.rowcount == 0:
        raise HTTPException(404, "Review not found")

    return {"detail": f"Review {review_id} deleted successfully"}

#---------------------------
# ANALYTICS → AVG RATING OF AN ARTICLE
# ---------------------------
@router.get("/analytics/article/{article_id}")
def get_article_rating_stats(article_id: str, db: Session = Depends(get_db)):
    sql = text("""
        SELECT 
            AVG(rating) AS avg_rating,
            COUNT(*) AS total_reviews
        FROM niche_data.reviews
        WHERE article_id = :aid
    """)
    row = db.execute(sql, {"aid": article_id}).mappings().first()

    return {
        "article_id": article_id,
        "avg_rating": round(float(row["avg_rating"]), 2) if row["avg_rating"] else None,
        "total_reviews": row["total_reviews"]
    }

'''
@router.post("/", response_model=ReviewOut)
def add_review(review: ReviewCreate, db: Session = Depends(get_db)):
    db_review = Review(**review.dict())
    db.add(db_review)
    db.commit()
    db.refresh(db_review)
    return db_review

@router.put("/{review_id}", response_model=ReviewOut)
def update_review(review_id: int, review: ReviewCreate, db: Session = Depends(get_db)):
    db_review = db.query(Review).filter(Review.review_id == review_id).first()
    if not db_review:
        raise HTTPException(status_code=404, detail="Review not found")
    for key, value in review.dict().items():
        setattr(db_review, key, value)
    db.commit()
    db.refresh(db_review)
    return db_review

@router.delete("/{review_id}")
def delete_review(review_id: int, db: Session = Depends(get_db)):
    db_review = db.query(Review).filter(Review.review_id == review_id).first()
    if not db_review:
        raise HTTPException(status_code=404, detail="Review not found")
    db.delete(db_review)
    db.commit()
    return {"detail": "Review deleted successfully"}
'''